# üåà 2-Light_Gest_Col_Prox ‚Äì Capteur TMG39931 (Couleur, Lumi√®re, Proximit√©)

Ce montage exploite le capteur **TMG39931** pour mesurer la **proximit√©**, la **lumi√®re ambiante** et les **couleurs RVB** via l‚Äôinterface **I2C**, √† l‚Äôaide d‚Äôune **carte Heltec WiFi LoRa 32 V3**. Les donn√©es sont affich√©es en temps r√©el sur un √©cran **OLED 128x64** avec la biblioth√®que **U8g2**, sans d√©pendre de biblioth√®ques Adafruit.

---

## üì∑ Image du montage

![Image du montage](./TMG39931.jpg)

---

## üõ†Ô∏è Mat√©riel utilis√©

| √âl√©ment             | D√©tails                        |
|---------------------|--------------------------------|
| **Microcontr√¥leur** | Heltec WiFi LoRa 32 V3         |
| **Capteur**         | TMG39931 (AMS/OSRAM)           |
| **Afficheur**       | OLED 128x64 (SSD1306 I2C)      |
| **Interface**       | I2C                            |

| Signal TMG39931 | Broche Heltec (J3) | GPIO |
|------------------|--------------------|------|
| SDA              | Pin 8              | 41   |
| SCL              | Pin 7              | 42   |

| Signal OLED  | GPIO Heltec par d√©faut |
|--------------|------------------------|
| SDA          | GPIO17                 |
| SCL          | GPIO18                 |
| RST          | GPIO21                 |

---

## üìö Biblioth√®ques utilis√©es

| Biblioth√®que    | Utilisation             |
|------------------|-------------------------|
| `Wire.h`         | Communication I2C       |
| `U8g2lib.h`      | Affichage OLED (U8g2)   |

---

## ‚öôÔ∏è Fonctionnement

Le programme :

1. Initialise le bus **I2C** sur **GPIO41/SDA** et **GPIO42/SCL** pour le capteur.
2. Initialise l‚Äô√©cran OLED via U8g2 (I2C logiciel sur GPIO17/18).
3. V√©rifie la pr√©sence du capteur √† l‚Äôadresse **`0x39`**.
4. Configure manuellement les registres du TMG39931 :
   - Temps d‚Äôint√©gration
   - Gain
   - Activation des modes Proximit√© & Couleur
5. Lit et affiche :
   - **Proximit√©**
   - **Composantes RVB**
   - **Canal Clear (C)**
   - **Flux lumineux estim√©**
   - **Valeurs RVB normalis√©es**
6. Affiche les donn√©es sur l‚Äô√©cran OLED **et** dans le moniteur s√©rie.
7. Commandes s√©rie disponibles :
   - `p` : Pause / Reprise des mesures
   - `r` : Red√©marrage de l‚ÄôESP32

---

## üß™ Param√®tres mesur√©s

| Mesure         | Description                                |
|----------------|--------------------------------------------|
| **Proximit√©**   | Valeur brute 8 bits                        |
| **Rouge, Vert, Bleu** | Intensit√© de chaque composante couleur |
| **Clear (C)**   | Intensit√© lumineuse globale                |
| **Flux lumineux** | Approximation simple en pond√©rant RVB    |
| **RVB Normalis√©s** | Chaque canal rapport√© √† la somme totale |

---

## üîç Adresse I2C

Le TMG39931 est fix√© √† l‚Äôadresse **`0x39`**, sans option de modification.

---

## üìÅ Fichiers inclus

- [`TMG39931.ino`](./TMG39931.ino) ‚Äì Code complet en C++ (Arduino)
- [`TMG39931.jpg`](./TMG39931.jpg) ‚Äì Capture √©cran OLED avec les mesures

---

## üí¨ Exemple de sortie console

```plaintext
------ New Measurements ------
Proximity: 142
Color values:
Red: 523
Green: 688
Blue: 312
Clear: 1120
Luminous Flux: 541.7
Normalized RGB: (0.345, 0.454, 0.201)
```

---

## üß† Remarques

- Le capteur offre aussi des fonctions de **gestes**, non activ√©es ici.
- La **normalisation RGB** permet d‚Äôavoir une estimation de teinte ind√©pendante de la luminosit√©.
- Le **flux lumineux** est approximatif ; pour une photom√©trie pr√©cise, il faut √©talonner le capteur.

---

## üñºÔ∏è D√©tails sur la biblioth√®que `U8g2lib.h`

La biblioth√®que **U8g2** est une solution puissante, compl√®te et autonome pour g√©rer les √©crans graphiques monochromes (comme les OLED SSD1306) sur plateformes Arduino et d√©riv√©es. Elle se distingue par sa **compatibilit√© √©tendue**, son **affichage haute qualit√©**, et une **gestion optimis√©e de la m√©moire** ‚Äì id√©ale pour les environnements embarqu√©s √† ressources limit√©es.

---

### üîß Pourquoi U8g2 ?

- ‚úÖ **Pas de d√©pendance √† Adafruit_GFX** (contrairement √† beaucoup d‚Äôautres biblioth√®ques OLED)
- ‚úÖ **Compatibilit√© avec des affichages I2C, SPI, parall√®les**
- ‚úÖ **Supporte les polices vectorielles (proportions, tailles, styles)**
- ‚úÖ **√âcriture de texte optimis√©e et fonctionnelle m√™me en mode tampon partiel**
- ‚úÖ **Performance ma√Ætris√©e**, avec des options pour √©quilibrer RAM/CPU/vitesse

---

### ‚öôÔ∏è Modes de fonctionnement

U8g2 propose **plusieurs modes de rendu** :

| Mode            | Description                                             | Usage conseill√©                    |
|------------------|---------------------------------------------------------|-------------------------------------|
| `full buffer`   | Toute l‚Äôimage est stock√©e en RAM avant affichage        | Meilleure qualit√©, n√©cessite ~1KB  |
| `page buffer`   | Affichage par pages (ex : 8 lignes √† la fois)           | Moins de RAM, plus lent            |
| `U8x8`          | Texte uniquement, sans tampon graphique                 | Ultra rapide, tr√®s √©conome         |

Dans ce projet, le mode **`full buffer`** est utilis√© pour afficher √† la fois du texte et de petites formes (lignes, s√©parateurs) avec fluidit√© et pr√©cision.

---

### üß© Initialisation dans ce projet

```cpp
#include <U8g2lib.h>

// I2C logiciel (bit-bang) sur GPIO17 (SDA), GPIO18 (SCL)
U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(
  U8G2_R0,     // Rotation normale
  /* clock=*/ 18, 
  /* data=*/ 17, 
  /* reset=*/ 21 // Broche RST d√©di√©e
);
```

üß† √Ä noter : L‚Äôutilisation du **mode logiciel (SW_I2C)** permet de lib√©rer les broches I2C mat√©rielles (GPIO41/42) pour le capteur TMG39931, √©vitant tout conflit.

---

### ‚úçÔ∏è Affichage dans la boucle

L'affichage est rafra√Æchi comme suit :

```cpp
u8g2.clearBuffer(); // Efface le tampon RAM
u8g2.setFont(u8g2_font_6x10_tf); // Police compacte et lisible
u8g2.drawStr(0, 10, "Proximity: 142");
u8g2.drawStr(0, 22, "Red: 523");
...
u8g2.sendBuffer(); // Transf√®re vers l'√©cran
```

Ce m√©canisme permet d‚Äôavoir un **affichage stable, sans scintillement**, tout en gardant le contr√¥le total sur la mise en page.

---

### üìè Performances et limitations

| Aspect             | √âvaluation                     |
|--------------------|--------------------------------|
| **Qualit√© texte**  | Excellente (plusieurs polices) |
| **Vitesse**        | Moyenne (due au bit-bang I2C)  |
| **M√©moire RAM**    | ~1KB en mode full buffer       |
| **Compatibilit√©**  | Tr√®s large (plus de 100 √©crans)|
| **Graphismes**     | Formes simples, sans images    |

Pour les projets n√©cessitant **des rendus graphiques pr√©cis avec peu de RAM**, U8g2 est souvent la meilleure option, bien plus sobre qu‚ÄôAdafruit_GFX.

---

### üß† Bonnes pratiques

- Choisir une **police compacte** (ex : `u8g2_font_6x10_tf`) pour afficher plus d‚Äôinformations sur l‚Äô√©cran 128x64.
- Regrouper les appels `drawStr()` avant un seul `sendBuffer()` pour optimiser les performances.
- Utiliser le **mode page buffer** si votre microcontr√¥leur a peu de RAM libre.
- Si seul du texte est affich√©, le mode `U8x8` peut acc√©l√©rer fortement l‚Äôaffichage (sans buffer RAM graphique).

---

### üîó Ressources utiles

- [Documentation officielle U8g2](https://github.com/olikraus/u8g2/wiki)
- [Liste des polices U8g2](https://github.com/olikraus/u8g2/wiki/fntlistall)
- [R√©f√©rences des fonctions](https://github.com/olikraus/u8g2/wiki/u8g2reference)

---
